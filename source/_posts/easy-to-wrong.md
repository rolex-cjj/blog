---
title: 算法中容易被忽视的问题
date: 2016-12-29 16:11:30
tags: [算法, C语言]
---

最近在看算法，实在是看不下去，可还是得硬着头皮看下去，毕竟要想活得比别人漂亮，找个好工作很关键啊！！！好了，转入正题，在看算法过程中，发现有几个问题是从来没有考虑的，我以为的结果却并不是实际的结果，就喜欢这种“不走寻常路”的感觉，哈哈哈~

### 问题一

先看下面一段简单的程序：

```c
#include<stdio.h>
int main()
{
	double i = 10.0000;
	if(i == 10)
		printf("i是10\n");
	for(i = 0; i != 10; i += 0.1)
	{
		printf("%.1f\n", i);
		if(i == 10)
			break;
	}
  return 0;
}
```

看着很简单是吧，你觉得结果会是什么呢？运行结果如下：

<!--more-->

```C
i是10
0.0
……
9.8
9.9
10.0
10.1
10.2
10.3
……
```

**解释：**

2进制的浮点数表示有一个很大的问题——它并不可以精确表示所有实数。只有可以写成2^a+2^b+2^c+...这种形式并且精度不能太多的实数才可以用浮点数来精确表示。而大多数实数仅仅保存了一个四舍五入后的**近似值**而已。譬如，0.1在单精度浮点数中实际值为0.100000001490116119384765625。

正是这种**非精确**的表示形式，造成了浮点数运算的误差。不管加减乘除，只要涉及到了浮点数，结果不是精确值，只是近似值。所以，在浮点数的运算中，请尽量避免用==比较结果，可以用 a+b<某个很小的数来代替。

### 问题二

再看一段小程序：

```c
#include<stdio.h>
int main()
{
	int count = 1;
	count = count++;
	
	printf("%d%d%d\n",count++,count++,count++);
	printf("%d\n",count);
  	return 0;
}
```

结果如下：

```c
321
4
```

**解释：**

首先，函数printf从左往右读取，然后将先读取放到栈底，最后读取的放在栈顶，处理时候是从栈顶开始的，所以我们看见的结果是，从**右边**开始处理的。

再者，如果一个表达式（或子表达式）只计算出值而不改变环境，我们就说它是引用透明的，这种表达式早算晚算对其他计算没有影响（不改变计算的环境。当然，它的值可能受到其他计算的影响）。如果一个表达式不仅算出一个值，还修改了环境，就说这个表达式有副作用（因为它多做了额外的事）。i++ 就是有副作用的表达式。其**非原子**操作。

程序语言通常都规定了执行中变量修改的最晚实现时刻（称为**顺序点**）。程序执行中存在一系列顺序点（时刻），语言保证一旦执行到达一个顺序点，在此之前发生的所有修改（副作用）都必须实现（必须反应到随后对同一存储位置的访问中），在此之后的所有修改都还没有发生。在顺序点之间则没有任何保证。

C/C++ 语言的规定告诉我们，任何依赖于特定计算顺序、依赖于在顺序点之间实现修改效果的表达式，其结果都没有保证。

所以这类代码不要写！！！

## 参考文献

[为什么浮点数运算会有误差](http://evol128.is-programmer.com/posts/29552.html)

[C/C++ 语言中的表达式求值](http://bbs.csdn.net/topics/370153775)